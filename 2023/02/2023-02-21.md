# 2023. 02. 21.

## Elasticsearch(7.10)

### 데이터 검색 - 검색 결과 페이징

#### 슬라이스된 스크롤

대량의 도큐먼트를 반환하는 스크롤 쿼리에서는 독립적으로 소비할 수 있는 여러 슬라이스로 나눌 수 있다:

```http
GET /my-index-000001/_search?scroll=1m
{
  "slice": {
    "id": 0,                      // 1. 슬라이스 ID
    "max": 2                      // 2. 슬라이스의 최대 수
  },
  "query": {
    "match": {
      "message": "foo"
    }
  }
}
GET /my-index-000001/_search?scroll=1m
{
  "slice": {
    "id": 1,
    "max": 2
  },
  "query": {
    "match": {
      "message": "foo"
    }
  }
}
```

첫 요청의 결과는 첫 번째 슬라이스(id: 0)에 속한 도큐먼트를 반환하고 두 번째 요청의 결과는 두 번째 슬라이스에 속한 도큐먼트를 반환한다. 슬라이스의 최대 수가 2로 설정됐으므로 두 요청을 결과를 합치면 슬라이싱 없이 스크롤 쿼리했을 때의 결과와 같다. 기본적으로, 이 분리는 각 샤드에서 먼저 다음 공식과 함께 _id 필드를 사용해 처리한다: `slice(doc) = floorMod(hashCode(doc._id), max)`. 예를 들어 샤드의 수가 2이고 사용자가 4 개의 슬라이스를 요청했다면 슬라이스 0과 2는 첫 번째 샤드에 할당되고 슬라이스 1과 3은 두 번째 샤드에 할당된다.

각 스크롤은 각 스크롤은 독립적으로 다른 스크롤 요청처럼 병렬로 처리될 수 있다.

> N이 샤드의 총 도큐먼트 수일 때 시간 복잡도가 O(N)이고 메모리 비용이 슬라이스당 N비트이기 때문에 슬라이스의 숫자가 샤드의 숫자보다 크면 첫 호출에서 슬라이스 필터가 매우 느리다. 몇 번의 호출 이후에는 필터가 캐싱되고 이후 호출은 더 빨라지지만 병렬로 수행하는 쿼리의 슬라이스 수를 제한해 메모리 폭발을 피하는 것이 좋다.

이 비용을 피하기 위해 다른 필드의 `doc_values`를 사용해 슬라이싱할 수 있지만 사용자는 해당 필드가 다음 프로퍼티를 갖는지 확인해야 한다:

* 필드가 숫자여야 한다.
* 해당 필드의 `doc_values`가 활성화돼야 한다.
* 모든 도큐먼트가 단일 값을 갖는 것이 좋다. 도큐먼트가 해당 필드에 여러 값을 가진 경우 첫 번째 값이 사용된다.
* 각 도큐먼트의 값은 도큐먼트가 생성될 때 한번 설정된 뒤 다시 갱신하지 않는 것이 좋다. 이는 각 슬라이스가 결정적인(deterministic) 결과를 내도록 한다.
* 필드의 카디널리티는 높은 것이 좋다. 이는 각 슬라이스가 겅의 동일한 수의 도큐먼트를 갖도록 한다.

```http
GET /my-index-000001/_search?scroll=1m
{
  "slice": {
    "field": "@timestamp",
    "id": 0,
    "max": 10
  },
  "query": {
    "match": {
      "message": "foo"
    }
  }
}
```

추가만 일어나는(append-only) 시간 기반 인덱스에서는 `timestamp` 필드를 사용하는 것이 안전하다.

> 기본적으로 스크롤 당 슬라이스의 최대 수는 1024로 제한된다. 인덱스 설정 `index.max_slices_per_scroll`을 업데이트해서 이 제한을 우회할 수 있다.

