# 2023. 08. 16.

## Elasticsearch(7.10)

### 쿼리 DSL - 특화된 쿼리

#### Percolate 쿼리

##### 사용 예시

###### 내부 동작 방식

도큐먼트를 [percolator 필드 타입][mapping-percolator] 매핑이 구성된 인덱스에 도큐먼트를 인덱스하면 도큐먼트의 쿼리 부분이 Lucene 쿼리로 파싱되 Lucene 인덱스에 저장된다. 쿼리의 바이너리 표현뿐만아니라 쿼리의 텀이 분석돼 인덱스 필드에 저장된다.

검색 시점에 요청에 지정된 도큐먼트는 Lucene 도큐먼트로 파싱돼 인 메모리 임시 Lucene 인덱스에 저장된다. 이 인 메모리 인덱스는 이 도큐먼트 하나만 가지며 여기에 최적화돼 있다. 이후 인덱스된 쿼리 텀을 기반으로 percolator 쿼리 후보를 선택하는 쿼리가 인 메모리 인덱스의 텀을 기반으로 구축된다. 그 다음 이 쿼리들은 실제로 일치하는지 인 메모리 인덱스에 의해 평가된다.

일치하는 후보 percolator 쿼리를 선택하는 것은 인 메모리 인덱스가 평가해야 하는 후보의 수를 크게 줄이기 때문에 `percolate` 쿼리 실행에서 중요한 성능 최적화다. `percolate` 쿼리가 이를 할 수 있는 이유는 percolator 쿼리를 인덱싱하는 동안 쿼리 텀이 percolator 쿼리로 추출되고 인덱스되기 때문이다. 유감스럽게도 percolator는 모든 쿼리로부터 텀을 추출할 수는 없(예를 들어 `wildcard`나 `geo_shape` 쿼리)으며 결과적으로 특정한 경우에서 percolator는 선택 최적화를 할 수 없다(예를 들어, 필요한 boolean 쿼리 절에 지원되지 않는 쿼리가 정의된 경우 혹은 지원되지 않는 쿼리가 percolator 도큐먼트의 유일한 쿼리인 경우). 이러한 쿼리들은 percolator에 의해 표시돼 다음 검색으로 찾을 수 있다:

```http
GET /_search
{
  "query": {
    "term" : {
      "query.extraction_result" : "failed"
    }
  }
}
```

> 위 예제는 매핑에 `percolator` 타입의 `query` 필드가 있다고 가정한다.

퍼콜레이션의 설계가 주어졌을 때 보통은 예제에서처럼 단일 인덱스를 사용하기보다는 percolate 쿼리와 퍼콜레이트되는 도큐먼트마다 별개의 인덱스를 사용하는 것이 타당하다. 이 접근 방식에는 몇 가지 이점이 있다:

- Percolate 쿼리는 퍼콜레이트되는 도큐먼트로부터 서로 다른 필드 집합을 갖기 때문에 두 개의 별도의 인덱스를 사용하는 것이 필드를 더 밀도 있고 효율적인 방법으로 저장되게 한다.
- Percolate 쿼리는 다른 쿼리처럼 스케일링하지 않으므로, 프라이머리 샤드의 숫자와 같이 서로 다른 인덱스 구성을 사용해 퍼콜레이션 성능에 이점을 가질 수 있다. 