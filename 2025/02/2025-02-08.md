# 2025. 02. 07.

## Reactor 3 Reference Guide

### Reactor Core 기능

#### Flux나 Mono를 만들고 구독하는 간단한 방법

##### 4. 배압 처리와 요청 변경(reshape) 방법

###### 4.1. 다운스트림에서 요구량(demand)를 바꾸는 연산자

염두에 둬야 할 것은 구독 수준에서 표현된 요구량은 업스트림 체인의 각 연산자에서 변경될 **수** 있다는 점이다. 전형적인 사례가 `buffer(N)` 연산자다. `request(2)`를 받으면 **두 개의 가득 찬 버퍼**에 대한 요구로 해석한다. 버퍼가 가득 차려면 `N`개 요소가 필요하므로, 결과적으로 `buffer` 연산자는 요청을 `2 * N`으로 바꾼다.

일부 연산자가 `int` 입력 파라미터를 받는 `prefetch`라는 이름의 변형을 가지고 있는 것을 눈치챘을지도 모른다. 이는 다운스트림 요청을 변형하는 또다른 카테고리의 연산자다. 주로 인입 요소로부터 (`flatMap` 처럼)`Publisher`가 파생되는 내부 시퀀스를 다루는 연산자다.

**사전인출**(Prefetch)은 이들 내부 시퀀스에서 만들어진 최초 요청을 조정하는 방법이다. 지정되지 않으면 대부분의 연산자는 요구량 `32`에서 시작한다.

이 연산자들은 주로 **보충 최적화**(replenishing optimization)도 구현한다. 연산자가 사전인출 요청의 75%가 완료된 것을 확인하면 업스트림에서 75%를 다시 요청한다. 이는 연산자가 올라오는 요청을 주도적으로 예측하는 휴리스틱 최적화다.

마지막으로 두 개의 연산자 `limitRate`와 `limitRequest`로 요청을 직접 조정할 수 있다.

`limitRate(N)`은 다운스트림 요청을 쪼개(split) 더 작은 배치(batch)로 업스트림에 전파되게 한다. 예를 들어, `100`의 요청에 `limitRate(10)`을 적용하면 최대 `10`개의 `10` 요청이 업스트림에 전파될 것이다. 이 형식에서 `limitRate`는 실제로 앞에서 봤던 보충 최적화를 구현한다는 점을 참고하라.

연산자는 (변형에서 `lowTide`로 참조하는)보충량을 조정할 수 있는 변형 `limitRate(highTide, lowTide)`도 가지고 있다. `lowTide`를 `0`으로 설정하면 보충 전략에 따른 추가 재요청 대신 `highTide` 요청의 **엄격한**(strict) 배치가 된다.

반면 `limitRequest(N)`은 다운스트림 요청에 총 요구량을 **제한**한다. 최대 `N` 개의 요청을 합산한다. 하나의 `request`가 `N`을 넘는 총 요구량 오버플로우를 발생시키지 않으면, 이 요청은 업스트림으로 그대로 전달된다. 요청받은 만큼 소스에서 방출된 뒤, `limitRequest`는 시퀀스가 완료된 것으로 간주하고 다운스트림에 `onComplete` 신호를 보낸 다음 소스를 취소한다.

