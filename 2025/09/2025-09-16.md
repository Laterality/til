# 2025-09-16

## Envoy

### 아키텍처 개요

#### 업스트림 클러스터

##### 서킷 브레이킹

서킷 브레이킹은 분산 시스템에서 핵심적인 요소다. 빠르게 실패하고 가능한 빨리 다운 스트림에 백프레셔를 적용하는 것이 거의 항상 더 낫다. Envoy 메시의 주요 이점 중 하나는 애플리케이션을 독립적으로 구성하고 코드를 작성할 필요 없이 Envoy가 서킷 브레이킹 제한을 네트워크 수준에서 적용한다는 점이다. Envoy는 다양한 유형의 (조율되지 않은)완전히 분산된 서킷 브레이킹을 지원한다:

* **클러스터 최대 커넥션**: Envoy가 하나의 업스트림 클러스터의 모든 호스트에 수립할 커넥션의 최대 수. 이 서킷 브레이커가 오버플로우하면 클러스터에 대한 [upstream_cx_overflow][config-upstream-clusters-cluster-manager-stats] 카운터가 증가한다. 모든 커넥션은 활성이든 드레인 중이든 이 제한에 걸린다. 이 서킷 브레이커가 오버플로우되더라도 Envoy는 클러스터 로드 밸런싱에 의해 선택된 호스트가 적어도 하나의 커넥션을 할당받도록 보장한다. 이는 클러스터의 [upstream_cx_active][[config-upstream-clusters-cluster-manager-stats]] 카운트가 최대 `cluster maximum connections + (number of endpoints in a cluster) * (connection pools for the cluster)` 까지 최대 커넥션 서킷 브레이커보다 높아질 수 있음을 암시한다. 이 제한은 모든 워커 스레드의 커넥션 합에 적용된다. 한 클러스터의 커넥션 풀이 가질 수 있는 커넥션에 대해서는 [커넥션 풀링][arch-upstream-clusters-connection-pooling-how-many]을 참고하라.
* **클러스터 최대 대기 요청**: 준비된 커넥션 풀의 커넥션을 대기하는 동안 큐에 쌓일 최대 요청 수. 요청들은 요청을 바로 전달(dispatch)할 수 있는 업스트림 커넥션이 충분하지 않으면 대기중인 요청 목록에 추가된다. HTTP/2 커넥션의 경우 [최대 동시 스트림][api-common-protocol-http2-protocol-options-max-concurrent-streams]과 [커넥션 별 최대 요청][api-clusters-cluster-configuration-cluster-max-requests-per-connection]이 구성되지 않은 경우 모든 요청들은 같은 커넥션을 통해 멀티플렉스되므로 이 서킷 브레이커는 이미 수립된 커넥션이 없는 경우에만 히트할 것이다. 만약 이 서킷브레이커가 오버플로우하면 클러스터의 [upstream_rq_pending_overflow][config-upstream-clusters-cluster-manager-stats] 카운터가 증가한다. HTTP/3의 경우 동등한 HTTP/2의 [최대 동시 스트림][api-common-protocol-http2-protocol-options-max-concurrent-streams]과 [최대 동시 스트림][api-common-protocol-options-quic-protocol-options-max-concurrent-streams]이 된다.
* **클러스터 최대 요청**: 클러스터 내 모든 호스트가 언제든 미결(outstanding) 처리할 수 있는 최대 요청 수. 이 서킷 브레이커가 오버플로우하면 클러스터의 [upstream_rq_pending_overflow][config-upstream-clusters-cluster-manager-stats] 카운터가 증가한다.
* **클러스터 최대 활성 재시도**: 클러스터 내 모든 호스트가 언제든 미결(outstanding) 처리할 수 있는 최대 재시도 횟수. 일반적으로 [재시도 예산][api-clusters-circuit-breakers-thresholds-retry-budge]을 사용하는 것을 권장하지만, 서킷 브레이커를 선호할 경우 공격적으로 재시도를 서킷 브레이크하는 것이 좋다. 이렇게 함으로써 산발적인 재시도를 허용하되 전체적인 재시도 볼륨이 폭발해 대규모 실패로 이어질 수 없도록 한다. 이 서킷 브레이커가 오버플로우하면 클러스터에 대한 [upstream_rq_retry_overflow][config-upstream-clusters-cluster-manager-stats] 카운터가 증가한다.
* **클러스터 최대 동시 커넥션 풀**: 동시에 인스턴스화될 수 있는 커넥션 풀의 최대 수. [Original Src 리스너 필터][arch-other-features-ip-transparency-original-source-listener-filter]와 같은 일부 기능은, 커넥션 풀의 수에 제한이 없다. 클러스터의 동시 커넥션 풀이 고갈되면 유휴 상태인 것을 회수하려고 한다. 불가능한 경우 서킷 브레이커가 오버플로우한다. 커넥션은 주로 타임아웃되지만 커넥션 풀은 타임아웃되지 않는다는 점에서 [클러스터 최대 커넥션][arch-upstream-clusters-circuit-breaking-cluster-maximum-connections]과 차이가 있다. 커넥션은 자동으로 정리되지만 커넥션 풀은 그렇지 않다. 커넥션 풀이 기능하려면 최소한 하나의 업스트림 커넥션이 필요하다. 따라서 이 값은 [클러스터 최대 커넥션][arch-upstream-clusters-circuit-breaking-cluster-maximum-connections]보다 크지 않아야 한다. 이 서킷 브레이커가 오버플로우하면 클러스터의 [upstream_cx_pool_overflow][config-upstream-clusters-cluster-manager-stats] 카운터가 증가한다.

각 서킷 브레이킹 제한은 [구성 가능][config-upstream-clusters-circuit-breaking]하며 업스트림 클러스터별과 우선순위 별로 추적된다. 이는 분산 시스템의 서로 다른 요소를 독립적으로 튜닝하고 서로 다른 제한을 가질 수 있게 한다. 서킷 브레이커가 열리기 전까지 남은 리소스의 수를 포함한 서킷 브레이커의 현재 상태는 [통계][upstream-cluster-manager-statistics-circuit-breaker-statistics]를 통해 관측할 수 있다.

워커 스레드는 서킷 브레이커 리밋을 공유한다. 즉, 활성 커넥션 임계치가 500이면, 워커 스레이드 1은 498개의 활성 커넥션을 가지며, 워커 스레드 2는 2개의 커넥션만 할당된다. 구현체는 최종적으로 일관되므로, 스레드 간의 경합은 잠재적으로 제한을 초과하게 할 수 있다.

서킷 브레이커는 기본적으로 활성화되며 클러스터 별 1024개의 커넥션과 같은 보통의 기본값을 갖는다. 서킷 브레이커를 비활성화하려면 [임게치][faq-load-balancing-disable-circuit-breaking]를 허용된 최대치로 설정하라.

서킷 브레이킹은 HTTP 요청인 경우 라우터 필터가 [x-envoy-overloaded][config-http-http-filters-router-x-envoy-overloaded] 헤더를 설정할 것이다.

[config-upstream-clusters-cluster-manager-stats]: https://www.envoyproxy.io/docs/envoy/latest/configuration/upstream/cluster_manager/cluster_stats#config-cluster-manager-cluster-stats
[arch-upstream-clusters-connection-pooling-how-many]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/connection_pooling#arch-overview-conn-pool-how-many
[api-common-protocol-http2-protocol-options-max-concurrent-streams]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-http2protocoloptions-max-concurrent-streams
[api-clusters-cluster-configuration-cluster-max-requests-per-connection]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-max-requests-per-connection
[api-common-protocol-options-quic-protocol-options-max-concurrent-streams]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-quicprotocoloptions-max-concurrent-streams
[api-clusters-circuit-breakers-thresholds-retry-budge]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/circuit_breaker.proto#envoy-v3-api-field-config-cluster-v3-circuitbreakers-thresholds-retry-budget
[arch-other-features-ip-transparency-original-source-listener-filter]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_features/ip_transparency#arch-overview-ip-transparency-original-src-listener
[arch-upstream-clusters-circuit-breaking-cluster-maximum-connections]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking#arch-overview-circuit-break-cluster-maximum-connections
[config-upstream-clusters-circuit-breaking]: https://www.envoyproxy.io/docs/envoy/latest/configuration/upstream/cluster_manager/cluster_circuit_breakers#config-cluster-manager-cluster-circuit-breakers
[upstream-cluster-manager-statistics-circuit-breaker-statistics]: https://www.envoyproxy.io/docs/envoy/latest/configuration/upstream/cluster_manager/cluster_stats#config-cluster-manager-cluster-stats-circuit-breakers
[faq-load-balancing-disable-circuit-breaking]: https://www.envoyproxy.io/docs/envoy/latest/faq/load_balancing/disable_circuit_breaking#faq-disable-circuit-breaking
[config-http-http-filters-router-x-envoy-overloaded]: https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-overloaded-set
