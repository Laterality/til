# 2025-09-05

## Envoy

### 아키텍처 개요

#### 업스트림 클러스터

##### 집계 클러스터

###### 로드 밸런싱 예시

집계 클러스터는 등급화된(tiered) 로드 밸런싱 알고리즘을 사용하고 상위 등급이 각 클러스터의 모든 [우선순위][arch-upstream-clusters-load-balancing-priority-levels]에 대한 헬스 점수에 따라 서로 다른 클러스터로 트래픽을 분산시킨다. 지계 클러스터는 앞의 구성 앞의 구성과 다른 두 개의 클러스터가 포함된다.

집계 클러스터는 두 개의 주요 단계와 함께 등급화된 로드 밸런싱 알고리즘을 사용한다:

- **상위 등급**: 각 클러스터의 전체 헬스에 따라 서로 다른 클러스터로 트래픽을 분산
- **두 번째 등급**: 클러스터가 선택되면 클러스터의 고유 로드 밸런서(e.g. [ROUND_ROBIN][arch-upstream-clusters-load-balancing-weighted-round-robin], [MAGLEV][arch-upstream-clusters-load-balancing-maglev], etc.)로 트래픽 분산을 위임

<table>
<thead>
<tr><th colspan="5"><p>클러스터</th>
<th><p>1차 클러스터로의 트래픽</p></th>
<th><p>2차 클러스터로의 트래픽</p></th>
</tr>
</thead>
<tbody>
<tr><td colspan="3"><p>1차</p></td>
<td colspan="2"><p>2차</p></td>
<td colspan="2" rowspan="2"></td>
</tr>
<tr><td><p>P=0인 헬시 엔드포인트</p></td>
<td><p>P=1인 헬시 엔드포인트</p></td>
<td><p>P=2인 헬시 엔드포인트</p></td>
<td><p>P=0인 헬시 엔드포인트</p></td>
<td><p>P=1인 헬시 엔드포인트</p></td>
</tr>
<tr><td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>0%</p></td>
</tr>
<tr><td><p>72%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>0%</p></td>
</tr>
<tr><td><p>71%</p></td>
<td><p>1%</p></td>
<td><p>0%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>0%</p></td>
</tr>
<tr><td><p>71%</p></td>
<td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>100%</p></td>
<td><p>100%</p></td>
<td><p>99%</p></td>
<td><p>1%</p></td>
</tr>
<tr><td><p>50%</p></td>
<td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>50%</p></td>
<td><p>0%</p></td>
<td><p>70%</p></td>
<td><p>30%</p></td>
</tr>
<tr><td><p>20%</p></td>
<td><p>20%</p></td>
<td><p>10%</p></td>
<td><p>25%</p></td>
<td><p>25%</p></td>
<td><p>70%</p></td>
<td><p>30%</p></td>
</tr>
<tr><td><p>20%</p></td>
<td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>20%</p></td>
<td><p>0%</p></td>
<td><p>50%</p></td>
<td><p>50%</p></td>
</tr>
<tr><td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>100%</p></td>
<td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>100%</p></td>
</tr>
<tr><td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>72%</p></td>
<td><p>0%</p></td>
<td><p>0%</p></td>
<td><p>100%</p></td>
</tr>
</tbody>
</table>

> [!NOTE]
>
> 기본적으로 [오버프로비저닝 지수][arch-upstream-clusters-load-balancing-overprovisioning-factor]는 **1.4**다. 이 지수는 더 낮은 헬스 비율을 부스트시켜 부분 가용성에 고려한다. 예를 들어, 우선순위 수준이 **80%** 헬시이면 **1.4**를 곱한 **112%**로 상한인 **100%**을 넘는다. 즉, **100%**를 넘는 곱은 **100%**로 취급된다.

집계 클러스터 로드 밸런서는 먼저 모든 클러스터의 각 우선순위의 헬스 점수를 계산해 이들을 합한 다음 전체 합에 따라 트래픽을 할당한다. 합이 적어도 **100%**이면 결합된 트래픽 상한은 **100%**다. **100**보다 작으면 Envoy는 비율을 맞춰(정규화) 최종 분산 합이 **100%**가 되도록 한다.

**시나리오 A: 총 헬스 >= 100**

다음 두 개 클러스터가 있다고 하자:

* 세 개의 우선순위 수준을 가진 1차 클러스터: `20%, 20%, 10%` 헬시.
* 두 개의 우선순위 수준을 가진 2차 클러스터: `25%, 25%` 헬시.

1. `precent_healthy * overprovisioning_factor (1.4)`를 사용해 로우(raw) 헬스 점수를 계산한다. 각 상한은 **100**이다. 
    * 1차:
        * P=0: 20% × 1.4 = 28
        * P=1: 20% × 1.4 = 28
        * P=2: 10% × 1.4 = 14
        * **합**: 28 + 28 + 14 = 70
    * 2차:
        * P=0: 25% × 1.4 = 35
        * P=1: 25% × 1.4 = 35
        * **합**: 35 + 35 = 70
2. 합이 **100%**를 넘지 않도록 트래픽을 첫 번째 클러스터, 그 다음, ... 에 할당한다.
    * 1차 클러스터는 먼저 70%를 가져간다.
    * 2차 클러스터는 min(100 - 70, 70) = 30을 가져간다.
    * 결합된 총합은 70 + 30 = 100이다.
3. 내부적으로 우선순위에 따라 트래픽을 분산한다.
    * 1차 클러스터의 **70%**는 우선순위의 비율에 따라 **28** : **28** : **14**로 나눠진다. i.e.:
        * P=0 → 28%
        * P=1 → 28%
        * P=2 → 14%
    * 2차 클러스터의 **30%**는 먼저 P=0에 35를 갖지만 1차 클러스터가 70을 가져갔으므로:
        * P=0 → 30%
        * P=1 → 0%

따라서, 최종적으로 분산된 트래픽은:

* 1차 클러스터: `{28%, 28%, 14%}`
* 2차 클러스터: `{30%, 0%}`

**시나리오 B: 통 헬스 < 100**

때로는 헬스 점수 합인 **100**보다 작을 때가 있다. 이 경우, Envoy는 이를 '정규화'(normalize)해 각 클러스터와 우선순위가 비율에 따라 트래픽을 받도록 한다.

다음과 같다고 가정하자:

* 1차 클러스터: `20%, 0%, 0%`
* 2차 클러스터: `20%, 0%`

1. 로우 헬스 점수를 계산한다(같은 공식: **100**이 상한인 `percent_healthy * 1.4`):
    * 1차:
        * P=0: 20% × 1.4 = 28
        * P=1: 0 → 0
        * P=2: 0 → 0
        * **합**: 28 + 0 + 0 = 28
    * 2차:
        * P=0: 20% × 1.4 = 28
        * P=1: 0 → 0
        * **합**: 28 + 0 = 28
2. 총 로우 헬스 = 28 + 28 = **56** (100보다 작음)
3. 최종 합이 100%가 되도록 정규화.
    * 양쪽 클러스터는 `28 / 56 = 50%`가 된다.

따라서, 각 클러스터는 50%의 트래픽을 받는다. 그리고 각 클러스터의 모든 지분이 **우선수위 0**(28점)에 있고 나머지는 0이므로 최종 분산은:

* 1차 클러스터: `{50%, 0%, 0%}`
* 2차 클러스터: `{50%, 0%}`

이 시나리오들은 Envoy의 집계 클러스터가 엔드포인트의 전체 헬스 상태에 따라 클러스터가 받는 트래픽을 결정하는 방법을 보여준다. 모든 클러스터에 걸친 총 헬스와 우선순위가 **100**에 도달하거나 이를 초과하면 Envoy는 총합을 **100%**로 제한하고 이에 따라 할당한다. 총 합이 **100**보다 작으면, Envoy는 비율에 따라 총 합이 **100%**가 되도록 한다.

각 클러스터 내에서 우선순위 수준 또한 존중되며 계산된 헬스 점수에 따라 트래픽이 할당된다.

**정리**

이를 의사 알고리즘으로 정리하면 다음과 같다:

* **100%**를 상한으로 `(healthy% × overprovisioning factor)`를 사용해 각 우선순위 수준의 헬스 점수를 계산한다.
* 클러스터의 총 헬스 점수를 합치고 필요한 경우 정규화한다.
* 각 클러스터의 전체 트래픽에서의 지분(클러스터 우선순위 부하)을 계산한다.
* 각 클러스터 내에서 헬스 점수에 따라 우선순위들에 트래픽을 분산한다.
* 각 클러스터에서 최종 로드 밸런싱을 수행한다.

```
health(P_X) = min(100, 1.4 * 100 * healthy_P_X_backends / total_P_X_backends), where
                total_P_X_backends is the number of backends for priority P_X after linearization

normalized_total_health = min(100, Σ(health(P_0)...health(P_X)))

cluster_priority_load(C_0) = min(100, Σ(health(P_0)...health(P_k)) * 100 / normalized_total_health),
                where P_0...P_k belong to C_0

cluster_priority_load(C_X) = min(100 - Σ(priority_load(C_0)..priority_load(C_X-1)),
                         Σ(health(P_x)...health(P_X)) * 100 / normalized_total_health),
                         where P_x...P_X belong to C_X

map from priorities to clusters:
  P_0 ... P_k ... ...P_x ... P_X
  ^       ^          ^       ^
  cluster C_0        cluster C_X
```

로드 밸런시의 두 번째 등급에서, Envoy는 첫 번째 등급에서 선택된 클러스터에 트래픽을 넘긴다. 해당 클러스터는 [로드 밸런서 유형][arch-upstream-clusters-load-balancing-supported-load-balancers]에서 설명한 어떤 로드 밸런싱 알고리즘이든 적용할 수 있다.

[arch-upstream-clusters-load-balancing-priority-levels]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/priority#arch-overview-load-balancing-priority-levels
[arch-upstream-clusters-load-balancing-weighted-round-robin]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancers#arch-overview-load-balancing-types-round-robin
[arch-upstream-clusters-load-balancing-maglev]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancers#arch-overview-load-balancing-types-maglev
[arch-upstream-clusters-load-balancing-overprovisioning-factor]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/overprovisioning#arch-overview-load-balancing-overprovisioning-factor
[arch-upstream-clusters-load-balancing-supported-load-balancers]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancers#arch-overview-load-balancing-types
