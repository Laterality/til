# 2025-07-25

## Envoy

### 아키텍처 개요

#### 업스트림 클러스터

##### 서비스 디스커버리

###### 최종적 일관성 서비스 디스커버리에서

기존의 많은 RPC 시스템들은 서비스 디스커버리를 완전히 일관성있는(fully-consistent) 과정으로 취급한다. 이를 위해서는 Zookeeper, etcd, Consul 등과 같은 저장소를 기반으로 완전히 일관성있는 리더 선출을 사용한다. 우리의 경험상 이러한 기반 저장소를 대규모로 운영하는 일은 고통스럽다.

Envoy는 서비스 디스커버리가 완전 일관성을 필요로 하지 않는다는 아이디어에서부터 시작해 설계됐다. 그 대신 Envoy는 최종적으로 일관된 방법으로 메시에서 호스트가 들어오고 나간다고 가정한다. 서비스 간 Envoy 메시 구성을 배포하는 데 권장하는 방법은 [활성 헬스 체크][arch-upstream-clusters-health-checking]를 사용해 클러스터 헬스를 결정하면서 최종적으로 일관된 서비스 디스커버리를 사용한다. 이 패러다임은 몇 가지 이점이 있다:

* 모든 헬스 결정은 완전히 분산된다. 따라서 네트워크 단절은 우아하게 처리된다(애플리케이션이 단절을 우아하게 처리하는지와는 다른 이야기다).
* 업스트림 클러스터에 대한 헬스 체크가 구성되면 Envoy는 2x2 행렬을 사용해 호스트로 라우트할지 결정한다:

| 디스커버리 상태 | 헬스 체크 OK | 헬스 체크 실패       |
| --------------- | ------------ | -------------------- |
| 디스커버리됨    | 라우트       | 라우트하지 않음      |
| 부재            | 라우트       | 라우트하지 않음/삭제 |

* 호스트 디스커버리됨 / 헬스 체크 OK

    Envoy는 대상 호스트로 **라우트할** 것이다.

* 호스트 부재 / 헬스 체크 OK:

    Envoy는 대상 호스트로 **라우트할** 것이다. 설계는 디스커버리 서비스가 언제든 실패할 수 있다고 가정하기 때문에 이는 매우 중요하다. 호스트가 디스커버리 데이터에서 사라진 뒤에도 헬스 체크를 계속 통과하면 Envoy는 여전히 라우트할 것이다. 이 시나리오에서는 새 호스트를 추가하는 것이 불가능하더라도 기존 흐스트는 계속 정상적으로 동작한다. 디스커버리 서비스가 다시 정상적으로 동작하면 데이터는 다시 수렴할 것이다.

* 호스트 디스커버리됨 / 헬스 체크 실패

    Envoy는 대상 호스트로 **라우트하지 않을** 것이다. 헬스 체크 데이터가 디스커버리 데이터보다 더 정확하다고 가정한다.

* 호스트 부재 / 헬스 체크 실패

    Envoy는 대상 호스트로 **라우트하지 않고 삭제**할 것이다. 이는 Envoy가 호스트 데이터를 제거하는 유일한 상태다.

[arch-upstream-clusters-health-checking]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/health_checking#arch-overview-health-checking
