## 2022. 01. 07.

#### gRPC

#### 가이드 - 오류 처리(2)

##### 더 풍부한(richer) 오류 모델

앞에서 설명한 오류 모델은 공식 gRPC 오류 모델로, 모든 gRPC 클라이언트/서버 라이브러리가 지원하고 gRPC (protocol buffers나 다른)데이터 형식과는 독립적이다. 꽤 제한적이고 오류 상세 정보를 전달할 수 없다고 느꼈을 수도 있다.

하지만 데이터 형식으로 protocol buffers를 사용중이라면 [이곳][google-apis-error-design]에 설명된 Google에서 개발하고 사용중인 더 풍부한 오류 모델을 사용하는 것을 고려해보라. 이 모델은 서버가 하나 이상의 protobuf 메시지로 표현된 추가적인 오류 상세정보를 서버가 반환하고 클라이언트가 처리할 수 있도록 한다. 나아가 [에러 메시지 유형의 표준 집합][googleapi-error-set]을 명시하여 대부분의 공통된 요구사항(올바르지 않은 파라미터, 사용량(quota) 초과, 스택 트레이스 등)을 커버할 수 있다. 이 추가 오류 정보의 protobuf 바이너리 인코딩은 응답의 후속 메타데이터로 제공된다.

더 풍부한 오류 모델은 C++, Go, Java, Python, 그리고 Ruby 라이브러리에서 이미 지원되며 grpc-web과 Node.js 라이브러리는 이를 요청하는 이슈가 열려있다. 다른 언어 라이브러리도 추후에 지원될 수 있으므로 관심있다면 github 저장소를 확인해보라. 하지만 C로 작성된 grpc-core 라이브러리는 데이터 형식을 모르도록(agnostic) 하는 것이 목적이기 때문에 이후에도 이를 지원하지 않을 가능성이 높다.

Protocol buffers를 사용중이지 않은 경우에도 (후속 응답 메타데이터에 오류 상세정보를 넣는)비슷한 접근법을 사용할 수 있다. 하지만 API에서 실용적으로 이에 접근하려면 데이터 접근을 지원하는 라이브러리를 찾거나 개발해야 할 것이다.

하지만 이와 같은 확장된 오류 모델을 사용할지를 결정하는 데에 아래와 같은 중요한 고려사항들이 있다:

* 오류 상세정보 페이로드에 대한 요구사항과 예상 관점에서 확장된 오류 모델의 라이브러리 구현체는 언어 별로 일관되지 않을 수 있다.
* 기존의 프록시, 로거 및 다른 표준 HTTP 요청 프로세서는 오류 상세정보를 볼 수 없기 때문에 모니터링이나 다른 목적으로 활용할 수 없다.
* 후속 메타데이터의 추가적인 오류 상세정보는 head-of-line 블로킹을 방해하고 더 잦은 캐시 미스로 HTTP/2 헤더 압축 효율을 떨어트린다.
* 더 큰 오류 상세정보 페이로드는 (최대 헤더 크기와 같은) 프로토콜 제한에 걸려 사실상 원래 오류를 잃을 수 있다.



[google-apis-error-design]: https://cloud.google.com/apis/design/errors#error_model
[googleapi-error-set]: https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto