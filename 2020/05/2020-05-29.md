## 2020. 05. 29.

### OpenTracing - 애플리케이션 계측(4)

#### 개념적 예시

이 접근 방식을 구체적으로 알아보기 위한 예시가 있다:

이 예시에서 우리는 모바일 클라이언트에서 시작된 요청을 추적하고 작은 백엔드 서비스들을 따라 전파하고자 한다.

1. 먼저, 이 트랜잭션의 전체 흐름을 알아야 한다. 이 예시의 트랜잭션은 다음과 같은 형태이다:

   [diagram]

   모바일 클라이언트에서 (HTTP)웹 요청을 생성하는 사용자 액션으로 시작 -> 웹 티어(RPC) -> 인증 서비스(RPC) -> 과금 서비스(RPC) -> 리소스 요청 (API) -> 웹 티어에 응답(API) -> 클라이언트에 응답(HTTP)

2. 이제 트랜잭션  흐름에 대해 고수준의 개념적 이해를 갖게 되었다. 다양한 프로토콜과 프레임워크 중 일부를 계측할 수 있다. 최선의 선택은 RPC 서비스부터 시작하는 것일 것이다. 웹 서비스 뒤에서 일어나는(혹은 적어도 RPC 서비스를 직접 활용하는) 모든 일들에 대한 스팬을 얻기 쉬운 방법이기 때문이다.

3. 계측하기 알맞은 다음 컴포넌트는 웹 프레임워크이다. 웹 프레임워크를 추가함으로써 종단 간 추적이 가능하다. 개략적이긴 하지만 트레이싱 시스템은 전체 워크플로우를 포착할 수 있다.

   [diagram]

4. 이 지점에서 트레이스를 보고 우리의 작업이 가장 큰 가치를 제공할 수 있는 위치를 평가하고자 한다. 이 예시에서 우리는 이 요청을 가장 크게 지연시키는 것이 리소스가 할당되는 데 걸리는 시간임을 볼 수 있다. 리소스 API를 계측하여 리소스 요청이 다음과 같이 분리될 수 있다는 것을 알게 되었다:

   [diagram]

   리소스 요청(API) -> 컨테이너 시작(API) -> 스토리지 할당 (API) -> 시작 스크립트(API) -> 리소스 준비 응답(API)

5. 리소스 할당 프로세스 컴포넌트를 계측하여 상당한 시간이 리소스 프로비저닝 중에 있는 것을 볼 수 있다. 다음 단계는 약간 더 깊게 들어가 이 프로세스에서 최적화될 수 있는 부분이 있는지 보는 것이다. 어쩌면 리소스 프로비저닝을 순차적으로 하는 대신 병렬로 할 수 있을 수도 있다.

   [diagram]

6. 이제 가시성과 종단 간 워크플로우에 대한 기준치가 설정됐다. 이 요청에 대한 현실적인 외부 SLO를 나타낼 수 있다. 추가로, 내부 서비스에 대한 SLO를 나타내는 것 역시 업타임과 에러 예산(error budgets)에 관한 논의의 일부가 될 수 있다.

7. 다음 반복 주기에는 트레이스의 최상위 수준으로 돌아가서 가시성이 부족한 다른 거대한 스팬을 살펴보고 더 작은 단위로 계측한다. 가시성이 충분하다면, 그 다음 단계로 다른 트랜잭션으로 이동한다.

8. 반복한다.