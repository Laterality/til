# 2026-01-20

## Envoy

### 요청의 생명주기

#### 요청 흐름

##### 6. HTTP 필터 체인 처리

각 HTTP 스트림마다 HCM은 리스너와 네트워크 필터 체인에 대해 앞에서 설명한 패턴에 따라 [다운스트림 HTTP 필터][arch-http-http-filters]를 인스턴스화한다.

HTTP 필터 인터페이스는 세 종류가 있다:

- 요청 처리를 위한 콜백이 있는 [StreamDecoderFilter][envoy-http-filter-h]
- 응답 처리를 위한 콜백이 있는 [StreamEncoderFilter][envoy-http-filter-h]
- `StreamDecoderFilter`와 `StreamEncoderFilter` 둘 다 구현하는 [StreamFilter][envoy-http-filter-h]

디코더 필터 인터페이스를 보자:

```c++
virtual FilterHeadersStatus decodeHeaders(RequestHeaderMap& headers, bool end_stream) PURE;
virtual FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) PURE;
virtual FilterTrailersStatus decodeTrailers(RequestTrailerMap& trailers) PURE;
```

HTTP 필터는 커넥션 버퍼와 이벤트에 작업하기보다는 HTTP 요청의 수명주기를 따른다. 예를 들어, `decodeHeader()`는 바이트 버퍼 대신 HTTP 헤더를 인자로 받는다. 반환된 `FilterStatus`는 네트워크 및 리스너 필터와 같이 필터 체인 제어 흐름을 관리하는 능력을 제공한다.

HTTP/2 코덱이 HTTP 요청 헤더를 사용 가능하게 만들면 이들은 먼저 CustomFilter의 `decodeHeaders()`로 전달된다. 반환된 `FilterHeadersStatus`가 `Continue`이면 HCM은 (CustomFilter에 의해 변형됐을 수도 있는)헤더를 라우터 필터로 전달한다.

디코더와 인코더-디코더 필터가 요청 경로에서 실행된다. 인코더와 인코더-디코더 필터는 응답 경로에서 [역방향][arch-http-http-filters-filter-ordering]으로 실행된다.

`decodeHeaders()`가 [라우터][arch-http-http-routing] 필터에 호출되면 라우트 선택이 마무리되고 클러스터가 선정된다. HCM은 HTTP 필터 체인 실행 시작시 자신의 `RouterConfiguration`으로부터 라우트를 선하한다. 이를 *캐시된 라우트*라 한다. 필터는 헤더를 변형할 수 있고 새 라우트가 선택되게 할 수 있으므로, HCM에 라우트 캐시를 비우고 라우트 선택을 재평가하도록 요청한다. 필터는 `setRoute` 콜백으로 이 캐시된 라우트를 직접 설정할 수도 있다. 라우터 필터가 호출되면 라우트가 마무리된다. 선택된 라우트의 구성은 업스트림 클러스터 이름을 가리키고 있을 것이다. 라우터 필터는 이후 클러스터에 대한 HTTP [커넥션 풀][arch-upstream-clusters-connection-pooling]에 대한 `ClusterManager`를 요청한다. 이는 다음 섹션에서 논의할 로드 밸런싱과 커넥션 풀을 동반한다.

결과 HTTP 커넥션 풀은 라우터에서 업스트림 HTTP 요청에 대한 HTTP 인코딩과 디코딩 콜백 메서드를 캡슐화하는 `UpstreamRequest` 객체를 구축하는 데 쓰인다. HTTP 커넥션 풀의 커넥션에 스트림이 할당되면, 요청 헤더는 `UpstreamRequest::encodeHeaders` 호출로 업스트림 엔드포인트로 포워드된다.

라우터 필터는 HTTP 커넥션 풀로부터 할당받은 업스트림 요청 스트림의 수명주기 관리의 모든 측면을 책임진다. 요청 타임아웃, 재시도 및 어피니티(affinity)에 대한 책임도 갖는다.

라우터 필터는 [업스트림 HTTP 필터][arch-http-http-filters] 체인의 생성과 실행에 대한 책임도 갖는다. 기본적으로 업스트림 HTTP 필터는 헤더가 라우터 필터에 도착하면 즉시 실행을 시작하지만, C++ 필터는 업스트림 스트림이나 커넥션을 조사(inspect)해야 하는 경우 업스트림 커넥션이 수립될 때까지 일시 중단할 수 있다. 업스트림 HTTP 필터 체인들은 기본적으로 클러스터 구성을 통해 구성되므로, 예를 들어 섀도우된 요청은 1차(primary)와 섀도우된 클러스터에 대해 개별 업스트림 HTTP 필터 체인을 가질 수 있다. 또한 업스트림 HTTP 필터 체인은 라우터 필터의 업스트림이므로, 각 재시도마다 헤더 조작이 가능하고 업스트림 스트림과 커넥션에 대한 정보를 포함해 실행된다. 다운스트림 HTTP 필터와는 달리, 업스트림 HTTP 필터는 라우트를 바꿀 수 없다.

[arch-http-http-filters]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_filters#arch-overview-http-filters
[envoy-http-filter-h]: https://github.com/envoyproxy/envoy/blob/06b4b053ba1581676895912ab1ac41f87c0a49e7/envoy/http/filter.h
[arch-http-http-filters-filter-ordering]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_filters#arch-overview-http-filters-ordering
[arch-http-http-routing]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_routing#arch-overview-http-routing
[arch-upstream-clusters-connection-pooling]: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/connection_pooling#arch-overview-conn-pool
